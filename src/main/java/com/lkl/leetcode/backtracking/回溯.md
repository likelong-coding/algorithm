**回溯算法模板**

结果可以定义为全局变量
```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    // for循环遍历树的宽度，剪枝一般也是从宽度入手，还有就是题目一些已知条件也可以用作剪枝
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归，树的深度
        递归之后，回溯，撤销处理结果
    }
}
```

回溯算法：**模板 + 剪枝**
    最好是能画出对应多叉树型结构，便于理解和剪枝
    ；回溯算法的实质就是穷举搜索，剪枝可以


一般可能还涉及`结果去重`，
结果去重有两种方式：
①排序，将相同的元素搞到一块，然后同层有相同的元素直接跳过
②无法排序的，只能每层借助额外空间进行去重


**组合问题、切割问题、排列问题、子集问题最后还有一个棋盘问题，一般都是回溯解法**

组合、切割以及排列都是收集叶子节点元素，子集就是收集树上的所有节点了

还有就是递归函数参数 `startIndex`有的需要有的不需要，这个参数可以控制每层树的开始位置，如果取过的元素不用再取了就可以用这个参数，
下一层就可以 +1，另一个参数`used 数组 `，标记数组中用过的元素不能再用了，不同的参数分情况考虑，如果是求和的话参数还可以有个`sum`维护当前和可与目标和`targetSum`作比较，相等时可以收集结果


